// API route for generating lightweight lesson outlines (title + description)
import { NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY

export const dynamic = 'force-dynamic'
export const runtime = 'nodejs'
export const maxDuration = 30

async function callOpenAI(prompt) {
  const key = process.env.OPENAI_API_KEY
  if (!key) {
    return {
      kind: 'new',
      title: 'Sample Lesson',
      description: 'This is a sample lesson description that would be generated by AI.'
    }
  }

  const url = 'https://api.openai.com/v1/chat/completions'
  const body = {
    model: process.env.SONOMA_OPENAI_MODEL || 'gpt-4o',
    messages: [
      { role: 'system', content: 'You are an educational content generator. Return only valid JSON with no markdown or code blocks.' },
      { role: 'user', content: prompt }
    ],
    temperature: 0.7,
    max_tokens: 300
  }

  const res = await fetch(url, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${key}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body)
  })

  if (!res.ok) {
    throw new Error(`OpenAI API error: ${res.status}`)
  }

  const data = await res.json()
  const text = data.choices?.[0]?.message?.content || '{}'
  
  // Remove markdown code blocks if present
  const cleaned = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim()
  
  return JSON.parse(cleaned)
}

function buildOutlinePrompt({ subject, grade, difficulty, preferences, context, promptUpdate }) {
  let preferencesText = ''
  
  if (preferences) {
    if (preferences.banned_topics?.length > 0) {
      preferencesText += `\n\nAVOID these topics: ${preferences.banned_topics.join(', ')}`
    }
    if (preferences.banned_words?.length > 0) {
      preferencesText += `\n\nDo NOT use these words: ${preferences.banned_words.join(', ')}`
    }
    if (preferences.focus_topics?.length > 0) {
      preferencesText += `\n\nPREFER lessons about: ${preferences.focus_topics.join(', ')}`
    }
    if (preferences.focus_keywords?.length > 0) {
      preferencesText += `\n\nEmphasize these concepts: ${preferences.focus_keywords.join(', ')}`
    }
  }

  // Add lesson history context if provided
  let contextText = context || ''

  let promptUpdateText = ''
  if (promptUpdate && String(promptUpdate).trim()) {
    promptUpdateText = `\n\nFACILITATOR PROMPT UPDATE (apply this when choosing topic/title/description):\n${String(promptUpdate).trim()}`
  }

  return `Generate a lesson outline for:
- Subject: ${subject}
- Grade: ${grade}
- Difficulty: ${difficulty}${preferencesText}${contextText}${promptUpdateText}

Return ONLY a JSON object with this exact structure:
{
  "kind": "new" | "review",
  "title": "A clear, engaging lesson title",
  "description": "A 2-3 sentence description of what the lesson will cover and teach"
}

Rules:
- If kind is "review", the title MUST start triggered and start with "Review:".
- If kind is "new", the title MUST NOT start with "Review:".

The lesson must be age-appropriate, educationally sound, and engaging. Keep the description concise but informative.`
}

function normalizeOutlineKind(raw) {
  const kind = String(raw || '').trim().toLowerCase()
  if (kind === 'review' || kind === 'revise' || kind === 'redo') return 'review'
  return 'new'
}

function ensureReviewPrefix(title) {
  const t = String(title || '').trim()
  if (!t) return 'Review: Untitled Lesson'
  if (t.toLowerCase().startsWith('review:')) return t
  return `Review: ${t}`
}

function stripReviewPrefix(title) {
  const t = String(title || '').trim()
  if (!t) return ''
  return t.replace(/^review:\s*/i, '').trim()
}

export async function POST(request) {
  try {
    const authHeader = request.headers.get('authorization')
    const token = authHeader?.replace('Bearer ', '')
    
    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
      global: { headers: { Authorization: `Bearer ${token}` } }
    })

    const { data: { user }, error: userError } = await supabase.auth.getUser(token)
    if (userError || !user) {
      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })
    }

    const body = await request.json()
    const { subject, grade, difficulty, learnerId, context, promptUpdate } = body

    if (!subject || !grade || !difficulty) {
      return NextResponse.json({ 
        error: 'Subject, grade, and difficulty are required' 
      }, { status: 400 })
    }

    // Fetch curriculum preferences if learnerId provided
    let preferences = null
    if (learnerId) {
      const { data } = await supabase
        .from('curriculum_preferences')
        .select('*')
        .eq('facilitator_id', user.id)
        .eq('learner_id', learnerId)
        .maybeSingle()
      
      preferences = data
    }

    // Generate outline using OpenAI
    const prompt = buildOutlinePrompt({ subject, grade, difficulty, preferences, context, promptUpdate })
    const outline = await callOpenAI(prompt)

    const kind = normalizeOutlineKind(outline?.kind || outline?.type)
    let title = outline?.title || 'Untitled Lesson'
    if (kind === 'review') {
      title = ensureReviewPrefix(title)
    } else {
      // Avoid accidentally labeling new lessons as review.
      const stripped = stripReviewPrefix(title)
      title = stripped || title
    }

    return NextResponse.json({ 
      outline: {
        kind,
        title,
        description: outline.description || 'No description available.',
        subject,
        grade,
        difficulty
      }
    })
  } catch (err) {
    console.error('Generate lesson outline error:', err)
    return NextResponse.json({ 
      error: 'Failed to generate lesson outline',
      details: err.message 
    }, { status: 500 })
  }
}
